name: CD

on:
  workflow_run:
    workflows: [ "CI" ]
    types: [ completed ]

jobs:
  deploy:
    name: Deploy to Kubernetes
    if: >
      ${{ github.event.workflow_run.conclusion == 'success' && github.event.workflow_run.name == 'CI' }}
    runs-on: ubuntu-latest
    env:
      REGISTRY: cr.yandex
      REGISTRY_ID: ${{ secrets.YCR_REGISTRY_ID }}
      IMAGE_TAG: ${{ github.event.workflow_run.head_sha }}
      NAMESPACE: task-manager
    steps:
      - name: Checkout repository at CI commit
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_sha }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4

      - name: Prepare kube dir
        run: |
          mkdir -p $HOME/.kube

      - name: Install Yandex Cloud CLI
        run: |
          curl -sSL https://storage.yandexcloud.net/yandexcloud-yc/install.sh | bash -s -- -a
          echo "$HOME/yandex-cloud/bin" >> $GITHUB_PATH
          echo "yc version:" && $HOME/yandex-cloud/bin/yc --version

      - name: Configure YC auth
        env:
          YC_OAUTH_TOKEN: ${{ secrets.YC_OAUTH_TOKEN }}
          YC_CLOUD_ID: ${{ secrets.YC_CLOUD_ID }}
          YC_FOLDER_ID: ${{ secrets.YC_FOLDER_ID }}
        run: |
          # Configure yc to be able to exchange OAuth to IAM token
          $HOME/yandex-cloud/bin/yc config set token "$YC_OAUTH_TOKEN"
          $HOME/yandex-cloud/bin/yc config set cloud-id "$YC_CLOUD_ID"
          $HOME/yandex-cloud/bin/yc config set folder-id "$YC_FOLDER_ID"
          # Optional: disable interactive prompts
          $HOME/yandex-cloud/bin/yc config set core.retry-interval 0s || true

      - name: Fetch kubeconfig from YC
        env:
          YC_CLUSTER_ID: ${{ secrets.YC_CLUSTER_ID }}
        run: |
          # Obtain kubeconfig for the managed Kubernetes cluster with public endpoint
          $HOME/yandex-cloud/bin/yc managed-kubernetes cluster get-credentials \
            --id "$YC_CLUSTER_ID" \
            --external \
            --force
          kubectl config current-context || true

      - name: Patch kubeconfig exec path to yc
        run: |
          # Replace any absolute path to yc in kubeconfig with plain 'yc' (uses PATH)
          sed -i 's|/Users/islebedev/yandex-cloud/bin/yc|yc|g' $HOME/.kube/config
          sed -i 's|/home/runner/.*/yc|yc|g' $HOME/.kube/config || true
          echo "Patched kubeconfig:" && grep -n "command: yc" -n $HOME/.kube/config || true

      - name: Check Kubernetes API connectivity
        run: |
          set -e
          echo "kubectl version:"
          kubectl version --short --request-timeout=20s || true
          echo "cluster-info:"
          kubectl cluster-info --request-timeout=20s
          kubectl get ns -A --request-timeout=20s >/dev/null

      - name: Wait for images to appear in YCR
        env:
          YC_OAUTH_TOKEN: ${{ secrets.YC_OAUTH_TOKEN }}
        run: |
          echo "Logging in to YCR to check images..."
          echo "$YC_OAUTH_TOKEN" | docker login ${REGISTRY} -u oauth --password-stdin

          BACKEND_IMAGE="${REGISTRY}/${REGISTRY_ID}/task-manager-backend:${IMAGE_TAG}"
          FRONTEND_IMAGE="${REGISTRY}/${REGISTRY_ID}/task-manager-frontend:${IMAGE_TAG}"

          echo "Waiting for images:"
          echo "  $BACKEND_IMAGE"
          echo "  $FRONTEND_IMAGE"

          for i in $(seq 1 60); do
            docker manifest inspect "$BACKEND_IMAGE" >/dev/null 2>&1 && B_OK=1 || B_OK=0
            docker manifest inspect "$FRONTEND_IMAGE" >/dev/null 2>&1 && F_OK=1 || F_OK=0
            if [ "$B_OK" = "1" ] && [ "$F_OK" = "1" ]; then
              echo "Both images are available in YCR."
              exit 0
            fi
            echo "[$i/60] Images not ready yet. Retrying in 10s..."
            sleep 10
          done
          echo "Images not found in YCR within timeout." >&2
          exit 1

      - name: Ensure namespace exists
        run: |
          kubectl get ns ${NAMESPACE} || kubectl create ns ${NAMESPACE}

      - name: Create/Update imagePullSecret for YCR
        env:
          YC_OAUTH_TOKEN: ${{ secrets.YC_OAUTH_TOKEN }}
        run: |
          kubectl delete secret ycr-pull-secret -n ${NAMESPACE} --ignore-not-found
          kubectl create secret docker-registry ycr-pull-secret \
            --docker-server=${REGISTRY} \
            --docker-username=oauth \
            --docker-password=${YC_OAUTH_TOKEN} \
            -n ${NAMESPACE}
          # Attach pull secret to default service account
          kubectl patch serviceaccount default -n ${NAMESPACE} \
            -p '{"imagePullSecrets": [{"name": "ycr-pull-secret"}]}' --type=merge || true

      - name: Apply Kubernetes manifests
        run: |
          kubectl apply -f k8s/namespace.yaml || true
          kubectl apply -f k8s/mysql.yaml
          kubectl apply -f k8s/backend.yaml
          kubectl apply -f k8s/frontend.yaml

      - name: Update images to CI commit SHA
        run: |
          kubectl -n ${NAMESPACE} set image deployment/backend backend=${REGISTRY}/${REGISTRY_ID}/task-manager-backend:${IMAGE_TAG}
          kubectl -n ${NAMESPACE} set image deployment/frontend frontend=${REGISTRY}/${REGISTRY_ID}/task-manager-frontend:${IMAGE_TAG}

  notify:
    name: Notify Telegram
    runs-on: ubuntu-latest
    steps:
      - name: Notify Telegram (Final)
        if: always()
        env:
          JOB_STATUS: ${{ job.status }}
        run: |

          if [ "$JOB_STATUS" = "success" ]; then
            MSG="✅ Deploy success!"
          else
            MSG="❌ Deploy failed!"
          fi

          echo "Sending Telegram notification (status: $JOB_STATUS)"
          RESP=$(curl -sS -X POST "https://api.telegram.org/bot${{ secrets.TELEGRAM_TOKEN }}/sendMessage" \
            -d chat_id="${{ secrets.TELEGRAM_TO }}" \
            -d text="$MSG" || true)
          echo "Telegram response: $RESP" || true