name: CD

on:
  workflow_run:
    workflows: [ "CI" ]
    types: [ completed ]

jobs:
  deploy:
    name: Deploy to Kubernetes
    # Run only if CI succeeded and branch is main
    if: >
      ${{ github.event.workflow_run.conclusion == 'success' && github.event.workflow_run.name == 'CI' }}
    runs-on: ubuntu-latest
    env:
      REGISTRY: cr.yandex
      REGISTRY_ID: ${{ secrets.YCR_REGISTRY_ID }}
      IMAGE_TAG: ${{ github.event.workflow_run.head_sha }}
      NAMESPACE: task-manager
    steps:
      - name: Checkout repository at CI commit
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_sha }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4

      - name: Configure kubeconfig
        run: |
          mkdir -p $HOME/.kube
          echo "${{ secrets.KUBE_CONFIG }}" > $HOME/.kube/config
          chmod 600 $HOME/.kube/config
          kubectl config current-context || true

      - name: Install Yandex Cloud CLI
        run: |
          curl -sSL https://storage.yandexcloud.net/yandexcloud-yc/install.sh | bash -s -- -a
          echo "$HOME/yandex-cloud/bin" >> $GITHUB_PATH
          echo "yc version:" && $HOME/yandex-cloud/bin/yc --version

      - name: Configure YC auth
        env:
          YC_OAUTH_TOKEN: ${{ secrets.YC_OAUTH_TOKEN }}
        run: |
          # Configure yc to be able to exchange OAuth to IAM token
          $HOME/yandex-cloud/bin/yc config set token "$YC_OAUTH_TOKEN"
          # Optional: disable interactive prompts
          $HOME/yandex-cloud/bin/yc config set core.retry-interval 0s || true

      - name: Patch kubeconfig exec path to yc
        run: |
          # Replace any absolute path to yc in kubeconfig with plain 'yc' (uses PATH)
          sed -i 's|/Users/islebedev/yandex-cloud/bin/yc|yc|g' $HOME/.kube/config
          sed -i 's|/home/runner/.*/yc|yc|g' $HOME/.kube/config || true
          echo "Patched kubeconfig:" && grep -n "command: yc" -n $HOME/.kube/config || true

      - name: Wait for images to appear in YCR
        env:
          YC_OAUTH_TOKEN: ${{ secrets.YC_OAUTH_TOKEN }}
        run: |
          echo "Logging in to YCR to check images..."
          echo "$YC_OAUTH_TOKEN" | docker login ${REGISTRY} -u oauth --password-stdin

          BACKEND_IMAGE="${REGISTRY}/${REGISTRY_ID}/task-manager-backend:${IMAGE_TAG}"
          FRONTEND_IMAGE="${REGISTRY}/${REGISTRY_ID}/task-manager-frontend:${IMAGE_TAG}"

          echo "Waiting for images:"
          echo "  $BACKEND_IMAGE"
          echo "  $FRONTEND_IMAGE"

          for i in $(seq 1 60); do
            docker manifest inspect "$BACKEND_IMAGE" >/dev/null 2>&1 && B_OK=1 || B_OK=0
            docker manifest inspect "$FRONTEND_IMAGE" >/dev/null 2>&1 && F_OK=1 || F_OK=0
            if [ "$B_OK" = "1" ] && [ "$F_OK" = "1" ]; then
              echo "Both images are available in YCR."
              exit 0
            fi
            echo "[$i/60] Images not ready yet. Retrying in 10s..."
            sleep 10
          done
          echo "Images not found in YCR within timeout." >&2
          exit 1

      - name: Ensure namespace exists
        run: |
          kubectl get ns ${NAMESPACE} || kubectl create ns ${NAMESPACE}

      - name: Create/Update imagePullSecret for YCR
        env:
          YC_OAUTH_TOKEN: ${{ secrets.YC_OAUTH_TOKEN }}
        run: |
          kubectl delete secret ycr-pull-secret -n ${NAMESPACE} --ignore-not-found
          kubectl create secret docker-registry ycr-pull-secret \
            --docker-server=${REGISTRY} \
            --docker-username=oauth \
            --docker-password=${YC_OAUTH_TOKEN} \
            -n ${NAMESPACE}
          # Attach pull secret to default service account
          kubectl patch serviceaccount default -n ${NAMESPACE} \
            -p '{"imagePullSecrets": [{"name": "ycr-pull-secret"}]}' --type=merge || true

      - name: Apply Kubernetes manifests
        run: |
          kubectl apply -f k8s/namespace.yaml || true
          kubectl apply -f k8s/mysql.yaml
          kubectl apply -f k8s/backend.yaml
          kubectl apply -f k8s/frontend.yaml

      - name: Update images to CI commit SHA
        run: |
          kubectl -n ${NAMESPACE} set image deployment/backend backend=${REGISTRY}/${REGISTRY_ID}/task-manager-backend:${IMAGE_TAG}
          kubectl -n ${NAMESPACE} set image deployment/frontend frontend=${REGISTRY}/${REGISTRY_ID}/task-manager-frontend:${IMAGE_TAG}

      - name: Notify Telegram (Final)
        if: always()
        env:
          JOB_STATUS: ${{ job.status }}
        run: |
          set +e
          URL_FRONTEND=$(kubectl -n ${NAMESPACE} get svc frontend -o jsonpath='{.status.loadBalancer.ingress[0].hostname}{.status.loadBalancer.ingress[0].ip}' 2>/dev/null)
          LOGS_BACKEND=$(kubectl -n ${NAMESPACE} logs deploy/backend --tail=50 2>/dev/null || true)
          LOGS_FRONTEND=$(kubectl -n ${NAMESPACE} logs deploy/frontend --tail=50 2>/dev/null || true)

          if [ "$JOB_STATUS" = "success" ]; then
            MSG="✅ Deploy success for ${GITHUB_REPOSITORY}@main (#${GITHUB_RUN_NUMBER})\nCommit: ${IMAGE_TAG}\nFrontend: ${URL_FRONTEND}"
          else
            trim() { head -c 1800; }
            LOGS_BACKEND_TRIM=$(echo "$LOGS_BACKEND" | trim)
            LOGS_FRONTEND_TRIM=$(echo "$LOGS_FRONTEND" | trim)
            MSG="❌ Deploy failed for ${GITHUB_REPOSITORY}@main (#${GITHUB_RUN_NUMBER})\nCommit: ${IMAGE_TAG}\nWorkflow: CD\n\nBackend logs (tail):\n${LOGS_BACKEND_TRIM}\n\nFrontend logs (tail):\n${LOGS_FRONTEND_TRIM}"
          fi

          echo "Sending Telegram notification (status: $JOB_STATUS)"
          RESP=$(curl -sS -X POST "https://api.telegram.org/bot${{ secrets.TELEGRAM_TOKEN }}/sendMessage" \
            -d chat_id="${{ secrets.TELEGRAM_TO }}" \
            -d text="$MSG" || true)
          echo "Telegram response: $RESP" || true